# 位运算

## 按位运算符

按位运算符：按位与（```&```），按位或（```|```），按位异或（```^```），按位取反（```~```）。
注意与逻辑运算符进行区分：逻辑与（```&&```），按位或（```||```），逻辑非（```!```）。

逻辑运算符**没有逻辑异或**，逻辑运算符的结果为 ```bool``` 类型，其值只有 ```true``` 和 ```false``` ，不过， ```bool``` 类型其实也是整型的一种（1位整型），其真实值为 ```1``` 和 ```0``` 。实际上 ```true``` 和 ```false``` 为 C++ 中引入的一个关键字，编译器也是将其翻译为 ```1``` 和 ```0``` ，使用 ```cout``` 进行输出，也是输出为 ```1``` 和 ```0``` 。

代码
```cpp
    int a = 3;
    cout << "a = " << a << endl;
    cout << "a + true = " << a + true << endl;
    int b = 3 + true;
    cout << "b = " << b << endl;
    bool c = 3 + true;
    cout << "c = " << c << endl;
```

输出
```
a = 3
a + true = 4
b = 4
c = 1
```


## 移位运算符

左移和右移，都不应该超过被移动类型的位长，否则结果是未定义的。也就是说，对于 ```int``` 类型，最多进行32位的移位，对于 ```long long``` 类型，最多进行64位的移位。

左移运算符，相当于乘以2，溢出的高位部分丢掉，新增的低位部分全部补0。注意，数字位也可以溢出到符号位，这个情况会把符号位改写，其实也是符合预期的。

右移运算符，相当于除以2向下取整（无论是非负数还是负数，都是向下取整，与直接除以2进行对比）

对于有符号数，右移会在高位补充符号位，溢出的低位部分丢掉。对于无符号数，右移会在高位补充0。对于这一点，可以理解为，无符号数的符号位本身就是0，只不过它没有被存储到最高位中，而是被无符号类型所声明。

## 运算符优先级

他们都可以赋值运算符结合，除了单目运算符。

C++中的运算符优先级（简略版）

## 常用的几个位运算

### lowbit

lowbit的意思是整数的最低二进制有效位，看看为什么可以通过 ```x & -x``` 计算lowbit，比如二进制数 0b00010010 ，然后算一下 -x 的二进制，全部按位取反，变成0b11101101，然后+1，变成0b11101110，观察他们按位与的结果，为0b00000010 ，确实是 x 的lowbit。其实，添加负号的过程，就是**除了lowbit往后的位全部取反**，所以得出这个结果是不奇怪的。

```cpp
int lowbit(int x) {
    return x & -x;
}
```

一个数减去lowbit的结果，和它异或lowbit的结果是一致的，都是把lowbit这一位清空。而一个数加上lowbit的结果，是把其右边的连续一段1，换成一个恰好比它们大的最小的2的幂。

比如
```
x = 10101110
x += lowbit(x)
x = 10110000
```

在树状数组中，这个是在寻找管辖当前节点的上一个线段树的左子树的过程。（注意树状数组是一棵去掉了右子树的线段树）

再看看另一个 ```x & (x - 1)``` 的结果， 0b01101000 和 0b011010111 ，他们取&的结果 0b01010000，结果是很好理解的，某个数字减1，那么就是**lowbit和往后的位全部取反**，那么再取&之后就是消除掉lowbit。

注：由于2的幂在二进制下只有1个1，当其进行 ```x & (x - 1)``` 消除掉lowbit之后，剩余为0。否则如果不是2的幂，剩余不为0。

```cpp
bool is_power_of_2(int x) {
    return x > 0 && (x & (x - 1)) == 0;
}
```

### popcount
知道了lowbit之后，可以很方便的实现有多少个1的计数，也就是popcount。

```cpp
int popcount(int x) {
    int res = 0;
    while (x) {
        ++res;
        x ^= (x & -x); 
    }
    return res;
}
```

或者
```cpp
int popcount(int x) {
    int res = 0;
    while (x) {
        ++res;
        x &= (x - 1);
    }
    return res;
}
```

其实也可以使用非标准函数（反正C++中非标准的东西太多了，在算法竞赛中，G++编译器就是实际上真正的标准）

### 按汉明权重顺序枚举状态

在状压dp中，如果按popcount递增或者递减的顺序二进制枚举状态，可以避免重复枚举，而且天然形成一个DAG（因为在状压DP中，只有x & y == x的时候，x是y的前置状态（y比x多了某些新的1）

可以按下面的步骤构造一个与当前汉明权重相等的状态。
设现在状态是x
int t = x + lowbit(x);
根据上文的说法，加上一个lowbit为让x的最低位的一段连续的1，换成一个刚好比它大一点的2的幂。
(lowbit(t) / lowbit(x)) >> 1
也相当于
(lowbit(t) >> 1) / lowbit(x)

t是最低位的一段连续的1换成上一个刚好比它大一点的2的幂，然后t右移1位，也就是x原本的最低位的一段连续的1中的最高位。除以x最低位的连续的1中的最低位，就得到了 1 << (x最低位的连续的1的长度 - 1)
然后再将其减一，就相当于新的最低位为 (x最低位的连续的1的长度 - 1) 个1，记为t2
t2 = (lowbit(t) >> 1) / lowbit(x) - 1
由于t相当于是x的最低位的连续的1的最左边的那个1向左移动了1位，剩下的1丢掉。而 t2 则是相当于把剩下的1都移动到了最低位上，所以现在 (t | t2) 的汉明权重和原来的x相等。

如此，我们只需要一开始初始化x为拥有i个最低位1的状态，根据上面的过程可以按照递增顺序得到所有的拥有i个最低位1的状态（直到溢出）。在x超过n之后，由于x是递增顺序的，所以当前的x和后续的x都不再需要考虑。然后在外层循环枚举i，就能得到答案。注意如果外层枚举i=0时，内层是会死循环的，这里要特殊考虑。

```cpp
void show_bin(int x) {
    cout << "x = " << bitset<4>(x) << endl;
}

int lowbit(int x) {
    return x & -x;
}

void compressed_state_dp(int n) {
    // fill(dp, dp + 1 + n, ?);
    for (int i = 0; (1 << i) - 1 <= n; ++i) {
        for (int x = (1 << i) - 1; x <= n;) {
            // dp[x] = ?;
            show_bin(x);

            if (x == 0) {
                break;
            }
            int t1 = x + lowbit(x);
            int t2 = ((lowbit(t1) / lowbit(x)) >> 1) - 1;
            x = t1 | t2;
        }
    }
}
```

```
x = 0000
x = 0001
x = 0010
x = 0100
x = 1000
x = 0011
x = 0101
x = 0110
x = 1001
x = 1010
x = 0111
```

注意，由于是按照汉明权重递增顺序枚举 $[0,n]$ ，并不保证最后一个被枚举的数字一定是 $n$ ，如上面代码运行结果所示。同时，并不需要 $n = 2^i$ 或 $n = 2^i - 1$ ，实际上 $n$ 可以为任意自然数。 

## 二进制集合操作

### 集合的运算

并，按位或
交，按位与
补，按位取反（注意全集的长度和int/long long表示的范围是否一致）
差，x按位与 按位取反的y，也就是x交（y的补集）。
对称差，x和y的异或。

### 二进制枚举子集

可以按字典序降序的方式，枚举集合的每一个子集，不出现任何一次重复或遗漏。

这个最好手动模拟一下方便理解。每次就是把当前子集中的最低位的1取消，同时把比当前最低位还要低位的原集中的1全部复原的过程。当最高位的1被取消了之后，s就永远损失了最高位1。直到所有的最高位1都被取消掉。

所以一开始是字典序最大，最后是字典序最小。

```cpp
void do_on_sub_set(int sub_set) {
    cout << "sub_set = " << bitset<8>(sub_set) << endl;
}

void all_sub_set(int full_set, bool do_on_empty_sub_set = false) {
    for (int sub_set = full_set;; sub_set = (sub_set - 1) & full_set) {
        if (sub_set == 0) {
            if (do_on_empty_sub_set) {
            do_on_sub_set(sub_set);

            }
            break;
        }
        do_on_sub_set(sub_set);
    }
}

int main() {
    int full_set = 0b10010101;
    cout << "not contain empty set" << endl;
    all_sub_set(full_set, false);
    cout << "contain empty set" << endl;
    all_sub_set(full_set, true);
    return 0;
}
```

```
don't contain empty set
sub_set = 10010101
sub_set = 10010100
sub_set = 10010001
sub_set = 10010000
sub_set = 10000101
sub_set = 10000100
sub_set = 10000001
sub_set = 10000000
sub_set = 00010101
sub_set = 00010100
sub_set = 00010001
sub_set = 00010000
sub_set = 00000101
sub_set = 00000100
sub_set = 00000001
contain empty set
sub_set = 10010101
sub_set = 10010100
sub_set = 10010001
sub_set = 10010000
sub_set = 10000101
sub_set = 10000100
sub_set = 10000001
sub_set = 10000000
sub_set = 00010101
sub_set = 00010100
sub_set = 00010001
sub_set = 00010000
sub_set = 00000101
sub_set = 00000100
sub_set = 00000001
sub_set = 00000000
```

这个可以非常快地枚举m的所有子集

如果要枚举 $[0, 2^{n})$ 中的所有集合的子集，如果用两重暴力枚举的方法，是 $2^n*2^n = 4^n$ 的。使用二进制枚举子集的方法，可以变成 $3^n$ 。

```cpp
    const int n = 3;
    for (int full_set = 0; full_set < (1 << n); ++full_set) {
        all_sub_set(full_set, false);
        cout << endl;
    }
```

```
sub_set = 001

sub_set = 010

sub_set = 011
sub_set = 010
sub_set = 001

sub_set = 100

sub_set = 101
sub_set = 100
sub_set = 001

sub_set = 110
sub_set = 100
sub_set = 010

sub_set = 111
sub_set = 110
sub_set = 101
sub_set = 100
sub_set = 011
sub_set = 010
sub_set = 001
```

复杂度证明，对于 $[0,n)$ 中的每一个二进制位，在枚举 ```full_set``` 时只有两种情况，一种是取0，另一种是取1。显然枚举 ```full_set``` 的过程是 $\Theta(2^n)$ 的。考虑每一个二进制位的贡献，当其在 ```full_set``` 中为0时，它对第二层循环不产生贡献（只作为0被遍历1次），而当其为1时，它会让第二层循环的次数乘以2。对于 $n$ 个1都存在的情况，第一层循环中这样的情况有1种，第二层循环要执行 $2^n$ 次；对于有 $n - 1$ 个1存在的情况，第一层循环中这样的情况有 $n$ 种，第二层循环要执行 $2^{n-1}$ 次。

以此类推，总的复杂度为：

$$\sum\limits_{i=0}^{n} C_{n}^{i} 2^i $$

考虑二项式展开：

$$(1+2)^n = C_{n}^{0} \times 1^0 \times 2^n + C_{n}^{1} \times 1^1 \times 2^{n-1} + C_{n}^{2} \times 1^2 \times 2^{n-2} + \cdots + C_{n}^{n} \times 1^n \times 2^{0}$$

恰好等于上式，也就是说，总的复杂度为 $\Theta(3^n)$ 。
