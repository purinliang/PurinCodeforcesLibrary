# 数论

数论研究的基本都是整数，或者限定在自然数，或者进一步限定在正整数范围内的问题。

## 基本概念

### 整除

如果 $b$ 除以 $a$ 余数为 $0$ ，则称为 $a$ 整除 $b$ ，注意除和除以的区别。记作 $a | b$。否则称为不整除，中间画一条斜线。

### 因数和倍数

如果 $a|b$ ，那么 $a$ 是 $b$ 的一个因数（又称约数），而 $b$ 是 $a$ 的一个倍数。

一般都是指正因数，负因数一般都不考虑。因数都是一对一对出现的，在某些情况下，成对的这对因数是同一个，这时，这个数字是完全平方数，如 $1,4,9,16,25,\cdots$，完全平方数也可能有超过3个正因数，如16。

### 质数和合数

有且只有 $2$ 个正因数的正整数，称为质数。有大于 $2$ 个正因数的正整数，称为合数。由于正整数 $1$ 只有一个正因数，所以它也不是质数（不过在大部分情况下它的表现和质数们很像，可以统一处理，但是细节上有差别）。显然 $0$ 是特殊的，它可以理解成有无穷个正因数，也可以理解成没有正因数组成的对。

2是唯一的偶数的质数。当然这并没有什么特别的，只是因为奇偶在现实中很常见，所以2的倍数拥有了偶数这个名字。

10以内的质数，2，3，5，7
20以内的质数，2，3，5，7，11，13，17，19
100以内的质数，很难记清楚。可以用埃氏筛法来大批量算出，不要强行质因数分解。

由于10进制的特殊性，2的倍数，5的倍数（因为他们是10的因子）有很明显的特征。3的倍数，9的倍数（因为他们是10 - 1的因子）也有较明显的特征。

### 模意义下的运算

对正整数 $M$ 取模，在数学上记作 $\mod {M} $ ，或者称为同余运算。模运算的结果为除法的余数，并且余数在 $[0, M-1]$ 之间，不能是负数。对于C++来说，对于自然数，取余运算符 ```%``` 的结果就是模的结果。
通常写作 ``` int r = a % M;```。 

而对于负数来说， ```%``` 的结果是 $[-(M-1), 0]$ 之间的数字，对于不是 $0$ 的结果，要加上 $M$ 才能得到数学上要求的余数。

为了偷懒，通常写作 ``` int r = (a % M + M) % M;```。 

r即为数学上的余数，在 $[0, M-1]$ 之间。对此，存在唯一的数字k，使得

$$a = kM + r$$ ，利用这个公式可以证明一系列的运算。

比如

$$a \equiv b \mod {M}$$

称为a和b在模M的意义下同余，也就是他们对M取余的结果是相同的。

模意义加法
模意义减法
模意义乘法
模意义除法，是不一定存在的。

模意义幂（乘方） 相当于做了多次乘法，存在
模意义开平方根，见二次剩余
模意义开任意次方根，见n次剩余
模意义对数，见离散对数

#### 快速幂

对于乘方运算，由于n很大，可以用快速幂进行计算，避免做n次乘法。
```cpp
ll qpow(ll x, ll n, ll mod) {
    ll res = 1;
    for (; n; n >>= 1) {
        if (n & 1LL) {
            res = res * x % mod;
        }
        x = x * x % mod;
    }
    return res;
}
```

注意，上述代码有一系列**使用限制**。比如x最后不要超过mod，而且```x*x```不能溢出，```res*x```也不能溢出，n必须为自然数。mod可以不必为质数，但是如果mod为1，而n为0，这时候res应该是0，但是没有被取mod，所以返回的为1。这些限制是可以理解的，正常的题目是没有这一类问题的。如果n为负数，实际上是在做除法，而除法运算是需要特殊处理的，也不一定存在。

#### 慢速乘

慢速乘用来避免乘法溢出的问题，和上面那个吃饱了撑的快速幂的问题一样。

```cpp
ll smul_safe(ll a, ll b, ll mod) {
    if (a >= mod) {
        a %= mod;
    }
    ll res = 0;
    for (; b; b >>= 1) {
        if (b & 1LL) {
            res = (res + a) % mod;
        }
        a = (a + a) % mod;
    }
    return res;
}

ll qpow_safe(ll x, ll n, ll mod) {
    if (x >= mod) {
        x %= mod;
    }
    ll res = 1 % mod;
    for (; n; n >>= 1) {
        if (n & 1LL) {
            res = res * x % mod;
        }
        x = x * x % mod;
    }
    return res;
}
```


#### 快速乘


### 模意义下的乘法逆元
虽然模意义下没有除法，但是在特殊条件下可以用乘法逆元代替除法。乘以这个乘法逆元得到的结果，相当于进行了除法。

#### 费马小定理

对于质数，有下面的式子成立

$$a^{p-1}\equiv 1 \mod {p}$$

左边可以拆成
$$a^{p-1} = a \cdot a^{p-2}$$

我们称 $a^{p-2}$ 为 $a$ 的乘法逆元



代码
```cpp
/**
 * When mod is a prime
 */
ll qpow(ll x, ll n, ll mod) {
    ll res = 1;
    for (; n; n >>= 1) {
        if (n & 1LL) {
            res = res * x % mod;
        }
        x = x * x % mod;
    }
    return res;
}

ll inv(ll x, ll mod) {
    return qpow(x, mod - 2, mod);
}
```

欧几里得算法

扩展欧几里得算法

乘法逆元，快速求一组乘法逆元

gcd和lcm（欧几里得算法） 贝祖定理

威尔逊定理 p 可以整除 (p-1)! + 1为p是质数的充要条件（跟平方因子有关）

判断质数，试除法，米勒-罗宾

质因数分解，Pollard-Rho算法

筛法

埃拉托斯特尼筛

欧拉筛

筛法求质数

求最小质因数

求最小质因数的幂（保证积性函数都是线性时间求得）

积性函数的定义

求因数的个数

求因数之和

更奇怪的，求因数的平方和

其他特殊筛法

杜教筛

min25筛

莫比乌斯反演

洲阁筛


使用限制

欧拉定理

扩展欧拉定理

中国剩余定理

扩展中国剩余定理

模意义下的排列数与组合数

卢卡斯定理，扩展卢卡斯定理

离散对数 大步小步算法，扩展大步小步算法


原根

数论变换NTT

组合数学：

生成函数

指数型生成函数

狄利克雷生成函数

快速傅里叶变换

2次剩余

k次剩余

连分数与佩尔Pell方程
