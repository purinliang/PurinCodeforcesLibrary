## 进制

常见的进制有，十进制，二进制，八进制，十六进制。

### 二进制

在 C++ 14 中，以 ```0b``` 开头的数字字面量，会被编译器解读为二进制数字。

代码
```cpp
    int a = 0b1010;
    cout << "a = " << a << endl;
    int b = 0b1111;
    cout << "b = " << b << endl;
```

输出
```
a = 10
b = 15
```

### 八进制和十六进制

在 C++ 中，以 ```0``` 开头的数字字面量，会被编译器解读为八进制数字。也就是说，**前导零**是会有影响的！而以 ```0x``` 开头的数字字面量，会被编译器解读为十六进制数字。

不过，在已经有第一个 ```0b``` 或者 ```0``` 或者 ```0x``` 引导声明进制了之后，再添加额外的前导零，是符合预期的。

所以**格外注意前导零**和八进制的格式即可。

代码
```cpp
    int dec_a = 10;
    int bin_a = 0b10;
    int oct_a = 010;
    int hex_a = 0x10;
    cout << "dec_a = " << dec_a << endl;
    cout << "bin_a = " << bin_a << endl;
    cout << "oct_a = " << oct_a << endl;
    cout << "hex_a = " << hex_a << endl;
    int dec_b = 10;  // dec_b != 010
    int bin_b = 0b010;
    int oct_b = 0010;
    int hex_b = 0x010;
    cout << "dec_b = " << dec_b << endl;
    cout << "bin_b = " << bin_b << endl;
    cout << "oct_b = " << oct_b << endl;
    cout << "hex_b = " << hex_b << endl;
```

输出
```
dec_a = 10
bin_a = 2
oct_a = 8
hex_a = 16
dec_b = 10
bin_b = 2
oct_b = 8
hex_b = 16
```


### 进制转换

#### 整数的二进制转换

对于非负整数：

十进制到二进制的进制转换：使用短除法，每次除以2，将余数（二进制的最低位）保存起来。直到处理完毕，从二进制的最高位开始逐个输出到二进制的最低位。需要特殊处理只有一个0的情况。

二进制到十进制的进制转换：从二进制的最高位开始，保存临时结果，如果还有还没有转换的位，则将临时结果乘以2，然后再加上下一个二进制位。

对于负整数：

**十进制到二进制的进制转换**：先将其绝对值的二进制转换出来，然后根据补码的规则进行转换。对于负数来说，补码为其绝对值的原码的按位取反再+1。

**二进制到十进制的进制转换**：识别其符号位，首先确定其为负数，然后当前为补码，先-1然后按位取反得到其绝对值的原码，将其绝对值的原码转换为对应的十进制，然后添加上十进制的前导负号。

**原码**：用最高位二进制为表示符号位，后面的数字位部分，无论非负数还是负数都是表示其本身，问题在于会有+0和-0同时存在。

**补码**：也是用最高位二进制为表示符号位，后面的数字位部分，非负数表示其本身，负数则要按照上述规则进行转换。

#### 小数 / 定点数的二进制转换

#### 对于八进制和十六进制

八进制和十六进制可以通过按每3个二进制位和每4个二进制位进行分组与二进制相互转换。

同时，十进制和二进制之间的转换方法也适用于十进制和八进制之间的互相转换，十进制和十六进制之间的互相转换。

#### 对于其他进制

十进制和二进制之间的转换方法也适用于其他进制。如果某些进制存在负数，最简单的方式是用数组保存下来，然后进行额外的一次扫描，把临位的正负号进行抵消。
