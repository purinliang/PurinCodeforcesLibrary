# 整体二分

在常见的题目中，需要用到二分的题目，特征是最小化最大值或者最大化最小值（这一类问题有显著的单调性）。如果规定某个参数为 ```mid``` 时，则**存在贪心策略**，可以通过贪心策略求出此时的答案值 ```ans``` 。而答案值 ```ans``` 是关于这个参数**存在单调性**的。通常 ```bool check(int mid)``` 函数都是去检查二分枚举的“分组参数”（最常见的“分组参数”是滑动窗口的窗口大小）的限制下，最多/最少能分多少组。另一类问题则二分枚举“最小/最大余量”，比如在一个序列或者图中存在加油站，求最小的汽车油箱的容量），然后在这个“最小/最大余量”下使用贪心策略，能否到达终点（对于这一类问题，答案值 ```ans``` 的结果是 ```true``` 和 ```false``` 并且存在单调性。

二分枚举则是想要找到，另答案值 ```ans``` 满足某个限制下的，这个最小/最大的参数 ```mid``` 。一般来说，单次枚举 ```mid``` 后，使用的 ```bool check(int mid)``` 函数通常都是存在线性复杂度的做法的，也就是说，单次 ```check``` 的复杂度是 $O(n)$ 。设要求的参数的值域范围为 $V$ （并且下文假设 $V \geq n$ 且 $V \geq q$ 。则单次二分枚举该参数直到找到答案的复杂度是 $O(\log V * n)$ 。

那么，如果不使用整体二分，对于 $q$ 次询问，都进行独立的二分枚举，复杂度为 $O(q * \log V * n)$。

## 整体二分的复杂度

首先，对于不同的查询，他们会带上不同的查询参数，不放设为 ```k``` （常见的还有诸如 ```cnt``` 或者 ```len``` 之类的查询参数）。在枚举 ```mid``` 后使用贪心策略会求出对应的答案 ```ans_k``` 或者 ```ans_cnt``` 或者 ```ans_len```，在普通二分中，返回值为类似 ```k <= ans_k``` 的比较结果，但是在整体二分中，由于要回答不同的查询参数，所以返回值要改为 ```ans_k``` 。

如果保持 ```int check(int mid)``` 函数的复杂度仍为 $O(n)$ ，那么 $q$ 次询问整体的复杂度是多少呢？在这种写法下，每次枚举 ```mid``` 之后，会根据 ```int check(int mid)``` 的返回值 ```ans_k``` 和每个询问 ```q``` 中的 ```q.k``` 进行比较，将询问分类为类似“小于等于 ```mid``` ”和“大于 ```mid``` ”两类。

注意，这里二分只能保证每次**值域折半**，并不能保证每次询问数折半。这是我以前对整体二分最大的误解。

### 整体二分最多递归多深？

显然，二分枚举 `mid` 每次**值域折半**，深度为 $O(\log V)$。

### 整体二分调用多少次 ```check``` 函数？

**错误分析1**：每次询问调用 $O(\log V)$ 次 `check` 函数，所以 $q$ 次询问调用 $O(q * \log V)$ 次 `check` 函数。
**错误原因**：这个复杂度跟单独调用 $q$ 次二分查找没有区别了，一眼就知道是错的。在值域范围较大时，多次询问会共用同一次 `check` 。

**错误分析2**：类似线段树，对于值域范围为 $V$ ，每次二分分为左右两次子区间，子区间又再分子区间，最后一共分出 $V$ 个叶子节点，由线段树的复杂度可知，节点数量为 $2V$ 。所以 $q$ 次询问调用 $O(V)$ 次 `check` 函数。
**错误原因**：在二分值域的同时，询问也在不断被分为两类，最终只会真实存在最多 $q$ 个叶节点。

**正确分析**：分析方式类似于另一个问题：“往字典树 Trie 中插入 $q$ 次长度为 $\log V$ 的01字符串，最坏情况下有多少个节点？”，要使得节点数最多， $q$ 次询问应该尽可能分开，在最前面的 $i$ 满足 $2^i \leq q$ 层，他们是分不开的，总共占据了 $2^i - 1$ 个节点，从第一个满足 $2^i > q$ 的 $i$ 开始，第 $i$ 层无法被占满，每个询问独占一个叶子节点，剩余的长度恰好为 $\log V - i$ （因为我们假设了 $V \geq q$ 所以可以这样做），所以总的节点数为 $2^i - 1 + q * (\log V - i)$ ，由于我们是渐进分析，所以 $i = O(\log q)$ ，也就是说：答案为 $O(q * (\log V - \log q))$ 。

注意这里的减号不是所有情况都能吸收掉的，同时这一个减号的优化恰好代表了即使不做任何修改使用最暴力的 $O(n)$ 的 ```check``` 函数，整体二分相对于普通二分依然有着巨大的改进，尤其是当值域与询问数同阶或者甚至值域小于询问数时，答案为 $O(q)$ 。

况且，上面的分析是基于最坏情况进行的，事实上出题人不一定能想到有人会使用整体二分去做，如果没有特意构造出这个最坏情况（答案完全均匀分布）的话，可以知道对于随机生成的数据，很多询问的答案会集中在靠中间的位置，即便他们所带的其他参数有区别（例如对于区间 $[l, r]$ 的第 $k$ 小值，对于均匀的 $[l, r]$ 搭配上均匀的 $k$ ，仍然可能让很多区间的答案其实是同一个数字或者比较相近的数字，他们都会共用绝大部分的 ```check``` 函数。

### 整体二分中询问总共被遍历多少次？

**错误分析1**：类似线段树，每次询问 $q$ 被分为两类，然后递归给左右区间，最多 $\log q$ 层，所以答案为 $O(q * \log q)$ 。

**错误原因**：前面都说了，分类的依据是**值域折半**，从来不能保证是询问折半。

**错误分析1**：类似线段树，每次询问 $q$ 被分为两类，然后递归给左右区间，最多 $\log q$ 层，总共有 $2q$ 个节点，所以答案为 $O(q)$ 。

**错误原因**：错得更离谱了，问的根本不是节点数，是节点的长度之和。另外递归的层数也不是 $\log q$ 啊。

**正确分析**：值域每次折半，递归 $\log V$ 次，无论询问被分到左区间还是右区间，都必须被递归直到进入叶子节点。复杂度为 $O(q * \log V)$。

### 整体二分的复杂度

**假设 ```check``` 函数的复杂度为 $O(T)$** ，那么整体二分的复杂度为 $O(q * (\log V - \log q) * T + q * \log V)$ ，注意后面那一项可以被吸收掉了，即 $O(q * (\log V - \log q) * T)$ 。

如果使用最暴力的 $O(n)$ 的 ```check``` 函数，复杂度为 $O(q * (\log V - \log q) * n)$ 。

如果使用一些聪明的办法，比如使用数据结构，或者先给数组排个序（极少部分问题），那么可以做到 $O(\log n)$ 的 ```check``` 函数，复杂度为 $O(q * (\log V - \log q) * \log n)$。

对于一部分问题，答案的值域 $V$ 真的是会和数据规模 $n$ 同阶。对于很多问题，在离散化之后也是一样的，比如区间 $[l, r]$ 的第 $k$ 小值，值域一定是会和数据规模 $n$ 同阶，用离散化之后的编号代表每个数字，在最后回答的时候再统一替换为原序列的数字即可。而数据规模 $n$ 在大部分问题中都是和询问规模 $q$ 是同阶的（或者略小于询问规模以体现“多次查询”）。在**值域 $V$ 和询问规模 $q$ 同阶**的前提下，复杂度为 $O(q * T)$ 。

## 使用数据结构优化

整体二分是一个离线算法，那么可以做到很多多次在线二分不敢做的事情。

考虑如何优化整体二分，除了在对询问分组的时候可以用类似快速排序的思路分成左右，避免无用拷贝和额外空间消耗这一点无关紧要的优化。最重要的还是要优化 ```check``` 函数的复杂度。

还是以区间 $[l, r]$ 的第 $k$ 小值为例，在枚举猜测第 $k$ 小值为 `mid` 时，原序列中的数字被分为 `a[i] <= mid` 和 `a[i] > mid` ，分别用 `1` 和 `0` 表示。然后通过某种方法求出 $[l, r]$ 的区间和 `ans_k` ，然后与 $k$ 进行比较就能成功对询问进行分类了。

考虑上面所说的“某种方法”，我一开始选中的是直接整个序列 $O(n)$ 求前缀和然后对于每个询问都是 $O(1)$ 回答，因为我一开始考虑到询问的数量较多，所以要加快查询的速度。OI-wiki里面给的做法是用树状数组，我其实当时非常疑惑，那树状数组查询不应该是更慢的吗？

其实是因为，树状数组在对多次查询时有特殊的优化。我那个方法，对于每一次 ```check```，序列中的每个元素都会贡献 ```O(1)``` 的复杂度，因为毕竟是暴力枚举前缀和，通过上文的分析我们知道 ```check``` 函数的调用次数是 $O(q)$ ，那么总体复杂度自然是 $O(n * q)$ ，居然还能通过80%的数据（规模1e5）！说明很多询问其实共享了查询，没有跑满复杂度。

对于树状数组来说，只需要考虑产生贡献的元素，在其原序列下标的位置（不是离散化值域的位置，**不是权值树状数组**）修改为 `1` ，然后用树状数组求区间和 ```ans_k = sum(r) - sum(l - 1)``` 来和询问 `q` 的参数 `q.k` 进行比较。然后询问会被归为两类，对于归类到左区间的询问，这些元素中的一半依然会产生贡献，而对于归类到右区间的询问，这些元素都不会再产生贡献，做法是让右区间的询问 `q` 的参数 `q.k` 直接 `q.k -= ans_k` 表示在右区间的询问也不再需要再管任何 `a[i] <= mid` 的元素了。

考虑这些元素总共贡献了多少次，每次 `check` 时，值域左半的所有元素都会贡献，一共 $\log n$ 层。如果元素是均匀分布的，那么每一层贡献的元素都是 $n / 2$ ，总共 发生 $n \log n$ 次贡献。均摊给每一次`check`（总共 `q` 次 `check` ，且 `q` 约等于 `n`），差不多就是均摊 $\log n$ 次贡献。所以复杂度可以认为是 $O(q \log n)$ 。

然而，如果元素并不是均匀分布的，比如其聚集在最小的元素上或者其他被多次分配到值域左半的叶子上，只是把每一层贡献的元素数量从 $n / 2$ 变成了 $n$ 。
