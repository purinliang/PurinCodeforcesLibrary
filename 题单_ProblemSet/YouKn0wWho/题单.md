## 题单列表

https://youkn0wwho.academy/topic-list

通过Google帐号进行登录。

### Basics

这一章节看起来都是非常基础的，不适合我。但是里面有一些项里面有问题可以做。

#### Intro to Programming


1. What is Programming? 

    跳过。

### Data Structures (DS)

### Square Root Decomposition

这个章节国内应该是叫做根号分块。

88. Basic SQRT Decomposition
    	
    7. Hill Jumping

        https://www.codechef.com/AUG17/problems/HILLJUMP

        设计一个数据结构，维护一个整数序列，长度为n=10^5，支持两个操作：

        1. 输入i和k。起始位置是i,执行k次跳跃。每次跳跃，找出当前位置的右侧的第一个元素比他严格大的位置，如果这样的位置距离超过100格则停止。

        2. 输入L，R和x。给位置L和位置R之间的所有的元素增加x。

        初步印象：如果k不大，则操作1很容易暴力维护一个next序列，表示当前位置的下一个合法位置是什么，容易发现操作2实际上只需要更新其左侧和右侧最多100个元素的next，中间是不变的。但是这里k很大，使用倍增的想法也不靠谱，因为一个元素可以存在很多个prev,更新的复杂度还是太高了。

        这里从本章节的名字启发，试试看从分块去想。分块其实就是用懒标记直接优化的暴力。

        回到上面的思考，其实维护这个next序列的想法是对的。我们一定要先从最简单的形式出发。
        
        首先我们考虑只有操作1的情况，并且先考虑k很小的情况。对于一个静态的问题，我们可以用单调栈的方法一次性知道所有元素的next。如果不存在操作2,那么我们可以用倍增的方法维护k很大的情况。

        然后我们考虑加入操作2。如果维持倍增，因为一个元素可以存在很多个prev,更新的复杂度还是太高了。

        只能从本章节的hint出发了，或者说这是一个启示，引导我们应该优先考虑暴力算法。分块数据结构只是难写还有复杂度很高，但是其能够适应的范围是非常大的，因为他本质上是一种暴力操作。

        考虑操作2，对一段连续的区间内部来说，他们的内部的next是不需要改变的。然后我们也可以很方便知道这个区间中的最大值，如果左侧的元素在寻找next的时候不超过这个最大值就要落入这个区间里面了。

        等下，我完全忽略了这个题目的一个特殊限制条件，就是寻找next的时候最多找100个位置。但是k可以很大，趋近于n。所以优化的方向应该是让k快速衰减。

        我们优先考虑根号分块，而不是按100的大小进行分块，因为这个100对于优化操作2来说可能太小了。我们假设分块的大小为m。

        首先我们考虑操作1。每个块，我们维护一个单调递增的序列p，当块左边的元素ai询问下一步跳几次时，在序列p上进行二分，找出大于ai的第一个位置，然后在k中减去比ai大的元素的数量，再交给下一个区间。容易知道这样的区间最多有n/m个，每个区间求解的复杂度最多是logm，合起来是nlogm/m。对于一开始不完整的区间，我们先暴力一个一个比较直到碰到当前的右边界（或者k消耗殆尽），复杂度是m。总体的复杂度是m+nlogm/m。

        然后我们考虑操作2。容易知道[L, R]横跨整个完整区间的时候，他们的序列p不会改变（只不过要加上一个懒标记），而左右不完整的区间则会发生改变。复杂度是2m+n/m。总体的复杂度是m+n/m。

        容易知道操作1的复杂度更高，求解m+nlogm/m的最小值，没必要找出其严格的最小值，只需要知道他应该就在sqrt(n)附近。
